## 一.分配主体流程:,

主要分为四个环节:

1. 首先挑选出确定着色的寄存器,如果所有的虚拟寄存器都能够不冲突地获取物理寄存器,则分配流程结束

   否则记录暂时不分配物理寄存器的寄存器,记录为spillings, 记该环节为`alloc`

2. 环节2中对于spillings集合中的寄存器,对使用它们的上下文进行一遍扫描,在扫描过程中通过添加store和load类型指令

   的方式给它们分配局部空余的寄存器/从别的固定占有物理寄存器的虚拟寄存器手中借来的物理寄存器,记该环节为

   `handle spill`

3. 考虑调用上下文的重分配:

   出于于节省caller saved/节省callee saved的考虑,重新调整各个函数的寄存器组成

4. 寄存器合并:

   尽可能地合并能够减少mv指令的 vv和vp寄存器:

   * vv:虚拟寄存器和虚拟寄存器

   * vp:虚拟寄存器和物理寄存器

## 二.alloc过程

### (一)首先尝试寻找完美分配方案

1. 对函数的各个基本快中的虚拟寄存器**计算生命周期**, 计算结果为每个基本块的`live in,live out`

2. 然后根据计算出的虚拟寄存器的生存周期,对虚拟寄存器**建立干涉图** `live neighbors`

3. **基于kempe原理** 对干涉图进行化简,得到`last_to_colors`寄存器链表以及化简后的虚拟寄存器的干涉图`rest live neighbors`

   last_to_colors具有如下性质:不论rest live neighbors中的节点如何着色,先着色完rest live neighbors中节点后,按照顺序一定能够完美着色`last_to_colors` 中的剩余虚拟寄存器。

4. 如果化简后所有虚拟寄存器都加入了 `last_to_colors` ,则直接顺序着色last to colors,分配结束

5. 利用ssa和弦图性质:

   因为经过了中端的ssa 形式IR转化,得到的后端tac形式IR上建立的虚拟寄存器的干涉图很可能是弦图,所以先使用最大势算法得到完美消去序列,然后对该序列倒序进行着色, 如果干涉图是弦图,则该着色方案一定能够命中完美着色方案,如果该干涉图不是弦图,该着色方案也比随机着色有更高几率命中完美着色方案

6. 如果上述尝试都没有找到完美着色方案,失败终止.

### (二) 结合各种参数 启发式分配寄存器

* spill代价估计

  1. 简单地估计虚拟寄存器的spill代价:

     一个虚拟寄存器在某个指令的reg defs中出现,代价加1;一个虚拟寄存器在某个指令的reg use中出现,代价也加1

  2. 针对循环层数加权:

     如果一个虚拟寄存器出现在一个循环层数为n的块中,则它在该块中获得的spill 代价要乘以10^n^.

* 综合启发函数 影响着色顺序

  启发函数: `f: reg->(spillcost* 1000.0) / (nln * 1000.0 + 1.0)`

  ```rust
  其中,nln为跟该虚拟寄存器有冲突的虚拟寄存器地数量
  ```

  按照f(r)的值从大到小选择还未着色的虚拟寄存器进行着色.

  把spillcost放在分子以期望优先着色spill代价大的函数

  把nln放到分母,以期望优先着色对其他虚拟寄存器的可着色性影响较小的寄存器

  而不是直接使用`spillcost/nln`而是使用`(spillcost* 1000.0) / (nln * 1000.0 + 1.0)` 是为了避免发生除0错误以及避免分母的+1.0过于影响比值

## 三.handle spill过程

注意:spill前的alloc 会保留一些临时寄存器以处理此处逻辑

### (一)核心数据结构:

#### 1\.next occurs

类型(语义):   寄存器->列表<(寄存器下一次出现所在指令的下标,寄存器下次出现是否在def中)>

```
sysylib::backend::func::utils::Func
pub fn build_next_occurs(bb: &BB) -> HashMap<Reg, LinkedList<(usize, bool)>>
👇
建立下次出现表,依赖于上次calc live的结果
表元素 (index,if_def)表示下次出现 是在def中还是在use中
如果 有在同一个下标的指令中同时def和use,
（index,false)会在(index,true)前面
```

#### 2\.rentors 和 holders

rentors:HashMap<Reg,Reg>:

```
spilling寄存器 -> 该spilling寄存器借用物理寄存器
```

holders:HashMap<Reg,Reg>:

```
物理寄存器 -> 该物理寄存器的持有者  (可能是统一物理寄存器本身, 也可能是借用它的虚拟寄存器)
```

### (二)执行逻辑

对每个基本块:

1. 建立next occurs,初始化rentors和holders,同时建立 new insts

2. 遍历指令

3. 如果指令中所用的物理寄存器被某个虚拟寄存器借走了,则把该物理寄存器中此时所有的该虚拟寄存器的值写入栈上,然后根据需要读回(/不读回)物理寄存器原值

4. 如果该指令中只有物理寄存器,直接加入new inst,跳到处理吓一条

5. 如果指令中包含虚拟寄存器,且该虚拟寄存器没有借用到物理寄存器,则直接选择一个物理寄存器交给它借用,插入需要的load和store指令

6. 根据rentors和holders的情况修改原本的inst,然后加入new insts

7. 遍历到块的出入跳转指令,则先归还所有物理寄存器给原主,之后若发生借用只使用前面保留的临时寄存器

### (三)挑选要租借的寄存器的策略

1. 优先挑选局部空闲而且空闲时间刚好覆盖需要租借物理寄存器的虚拟寄存器的寄存器

2. 其次,优先使用之前保留的tmp寄存器

3. 综合,优先选择刚好空闲区域覆盖该虚拟寄存器剩余存活周期的寄存器,否则选择下一次使用最远的寄存器

## 四.考虑调用上下文的重分配

调用者和被调用者互相协调来调整自身的寄存器组成,以减少需要caller saved或者callee saved的数量

(略)

## 五.寄存器合并

1. 建立regs_used_but_not_saved该表记录了每个函数内部使用了但是内部没有restore的寄存器

2. 虚拟化已经实际汇编为虚拟汇编，对新产生的虚拟寄存器分析并建立可合并列表(能够减少mv指令)，以及建立干涉图

3. 根据regs used but not saved对于call指令前后存活的虚拟寄存器建立对 regs used but not saved的约束

4. 结合各种因素对可合并机会列表进行排序，以便获取更好合并结果

5. 把caller save和callee save相关的约束加入到寄存器干涉图中

6. 对合并机会列表中 的没对虚拟寄存器尝试 合并，判断合并后的 寄存器干涉图是否能够完美着色,如果可以，则合并