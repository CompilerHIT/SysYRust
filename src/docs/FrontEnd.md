# FrontEnd

## 中间代码生成(SysY -> SSA IR)

使用了语法解析器生成工具lalrpop(虽然是这个名但默认使用LR(1))，定义语法树节点，生成语法树之后，使用visitor设计模式，为每个语法树节点实现统一接口process,生成中间代码

(生成中间代码过程主要包括：符号表管理、作用域管理、数组维度获取、数组初始化、const变量初始化等比较琐碎的东西)

### 符号表管理

维护变量类型(i32或f32)、变量属性(局部数组、全局数组、全局变量、形参或者普通变量)

### 作用域管理

同层中不能存在多个同名变量

使用变量时若有多个同名变量存在，绑定层数最深的那个变量

每个变量都维护一个最新的值，直到这个变量的下一次定义前，使用这个变量都指向这个最新的值

注意形参变量所在层数(若全局层数为0，则形参层数为1,函数内第一层层数为2，依次类推)

出作用域时记得删除所有该层的变量(尤其是存在多个同名变量时，若删除有误最后生成的ir可能会出错)

### 数组维度

按照SysY语义定义，数组的维度具体是多少是可以编译时确定的，所以要求在ast归约，第一次生成中间代码时我们就需要考虑常量折叠(当然要过多遍pass也行，本项目中第一次生成ir的过程中就考虑了常量折叠)，用可以编译时可以计算出的值替换原变量，确定数组维度

### 数组的初始化

数组的初始化比较复杂，由于本项目的ir设计中，没有多维数组的抽象，所以对于一个多维数组，需要把其展平为一个一维数组，其初始化值也是一样，对于嵌套的初始化数组需要填充空缺的0以及识别每一个初始值到底对应数组的哪个元素

### 常量Const变量的初始化

按照SysY语义定义，Const变量的初始值是一个编译时可以确定的值，所以和上文数组维度一致，需要在第一次生成ir的过程中就考虑常量折叠

### 插phi

在ast归约，第一次生成中间代码时，如果在当前块没找到该变量，则插phi

### 填phi

在前继节点中找这个变量，找到则返回这个变量，作为phi参数

没找到则插phi，继续向上找，等填完新的phi后，将新phi作为参数返回，作为原来的phi的参数

### phi优化

对于参数去重之后，只剩一个参数或只剩两个参数，其中一个参数是phi本身的情况，这个phi可以删去

### 短路

**目的:后端处理与或表达式不方便，放到前端处理，将与或表达式信息以控制流图的形式直接给出，不再把与或指令传到后端**

基本思路:

当前块持有两个节点信息(bb_true和bb_false)，表示发生跳转时对应的块，难点转化为如何维护并在块间传递这两个信息

算法步骤:

龙书上有考虑回填，但是有点麻烦，根据语言定义给了一种解法



- 归约if,if else,while节点时生成新的块,设置bb_false和bb_true



- 归约cond1&&cond2节点时,首先生成cond1所在块c1和cond2所在块c2；

  此时bb_true和bb_false记为t1和f1；

  设置cond1所在块bb_true为c2,cond1所在块bb_false为f1;

  设置cond2所在块bb_true为t1,cond2所在块bb_false为f1;



- 归约cond1||cond2节点时,首先生成cond1所在块c1和cond2所在块c2；

  此时bb_true和bb_false记为t1和f1；

  设置cond1所在块bb_true为t1,cond1所在块bb_false为c2;

  设置cond2所在块bb_true为t1,cond2所在块bb_false为f1;



- 归约break节点时,生成无条件跳转指令,设置当前块后继节点为bb_false

  并设置stop_irgen标志为true,当前块中不再对后续语句做翻译



- 归约continue节点时,生成无条件跳转指令,设置当前块后继节点为bb_true

  并设置stop_irgen标志为true,当前块中不再对后续语句做翻译



**注:stop_irgen标志会在某些重要地方重置为false(比如if节点归约末尾,if else 归约中一个分支归约结束时,while归约末尾等),使得翻译过程继续进行**

## 中间代码优化

### Constant Folding

根据指令特性，将编译时可以确定指令用常量替代



### Global Value Numbering

全局值编号，用于将指令编号(或分类),同一类的指令代表相同的计算

gvn并不能解决所有的相同计算的识别，它和表达式的顺序有关，

比如可以识别a+b+c+d与a+b+d+c为同一计算，

但不能识别a+b+c+d与d+a+b+c为同一计算

gvn的实现可以通过设计hash函数给每条指令赋哈希值(也就是编号),也可以通过congruence的概念，将表示相同计算的指令放到一起

本项目中使用的gvn是通过第二种形式实现的,基本原理如下:

若两条指令操作符一致，且各对应操作数表示同一计算，那么这两条指令也表示同一计算

对应乘法,加法指令,满足交换律(仅对整型而言,浮点数不一定满足交换律,浮点数计算中交换计算次序可能会导致精度问题)

对于两条表示相同计算的不同指令，若其中一条指令a支配另外一条指令b，则指令b可以消除，指令b的user重新绑定为a的user，这可以消除支配节点间的重复计算，而对于局部的冗余计算则需要通过pre将冗余计算消除



### Partial Redundancy Elimination

局部冗余消除,若多个分支的共同后继节点中存在计算m，m在某一分支中也进行过计算，则将该计算添加到其他没有进行过该计算的分支中，并将公共后继节点中的计算m替换为一条phi指令

由于PRE主要是为了暴露优化空间，需要尽可能地把公共的计算移动到相同的支配各分支节点的前继节点中,所以PRE需要和hoist(指令上提)交替进行，直到该类指令集收敛到不动点为止

**注:当上移节点有多个后继时需要插块**



### Hoist

本项目中的hoist主要是基于gvn，由gvn确定同一计算再决定是否上提指令，由于可以上提的指令是存在于Congruence里的，所以我们仅在Congruence中进行遍历，而非遍历整个函数中的每一条指令(提高效率)

hoist时会对同质(congruent)的指令进行比较，如上文PRE中所提一致，对于同质的指令集会交替进行hoist和PRE操作，直到这个同质的指令集收敛到不动点为止



### Sink

PRE和Hoist是为了将消除局部冗余，并将公共的计算移动到支配这些节点的公共节点中，暴露一些可以优化的点(主要是循环中),但将指令上升后会导致有些变量存活时间太长，这会给后端的寄存器分配很多压力，所以在PRE,Hoist暴露出更多的优化空间，并进行循环优化之后，再将可以下沉的指令下沉的合适的位置，以减少变量的存活时间(需要注意下沉时不要改变循环优化的结果)



### Load Store Elimination

块间的load,store消除在这部分处理的ir中并不容易分析，该优化只有对同一块内多余的load,store进行了消除，保证了同一块内，对于同一变量的load指令最多只存在一个,store也是，同一块内对同一变量最多只存在一个store



### Block Opt

对于只有一条无条件跳转语句且删除该节点不影响其后继节点中phi指令的块

对于两个后继为同一块的情况进行修改，用一个后继和一条无条件跳转语句替代原有块结构和指令行为



### Trivial Opts

指令合并:

(只对整型处理)

对同一变量累加常量,折叠常量

对同一变量累乘常量,折叠常量

同个变量多次累加变为乘法

消除乘除1指令,消除加减0指令,消除0+指令

消除乘除同一数的指令

消除恒定比较表达式(两个操作数为同一值)



