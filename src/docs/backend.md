## 关于栈帧寄存器

由于sysy不涉及内联汇编，因此目前省略了s0的作为栈帧寄存器的特殊用法，从而使得寄存器分配过程多出一个非special的寄存器

## 涉及立即数跳转的j型指令和b型指令问题

若目标b/j型指令目标label大于4KB/1MB（如何得到目标block与pc的偏移以确定是否合法？）
解决：函数维护block编号，作差 \* 指令数 \* 代价

## 分支预测

如何尽可能保证程序顺序执行？

## gp优化

使用gp相对寻址(+- 2K)代替auipc + addi label

## stack structure

┌──────────────────┐
│                  │
│     params       │
├──────────────────┤
│                  │
│       ...        │
├──────────────────┤
│                  │
│   alloca array   │
├──────────────────┤
│                  │
│                  │
│                  │
│                  │
│                  │
│       ...        │
│                  │
│                  │
│                  │
├──────────────────┤
│                  │
│     local var    │
├──────────────────┤
│                  │
│     local var    │
└──────────────────┘
使用LinkedList，函数参数、数组使用头插，局部变量使用尾插；
对于发生函数调用前，保存在栈上的参数寄存器，同样使用头插，调用StoreParamToStack（认为发生溢出行为）
List结构如下：
┌────────────────┐◄───────list head
│                │
│                │
│    alloca1     │
│                │
│                │
├────────────────┤
│                │
│                │
│    alloca0     │
├────────────────┤
│      ...       │
├────────────────┤
│                │
│     param1     │
│                │
├────────────────┤
│                │
│     param0     │
│                │
├────────────────┤
│                │
│  local var0    │
├────────────────┤
│                │
│  local var1    │
├────────────────┤
│                │
│      ...       │
└────────────────┘◄───────list tail

> 使用“预估法”所以不用记录每个局部变量的位置，即在stackslot中不保存local var

## alloca数组

通过la label获取数组第0个元素地址，一次ld加载两个数组值到栈上

## 优化跳转： 如果func的block集合中，下一个block是当前block的跳转对象，则省去跳转指令

## 压缩数据

由于使用的数值都是32位，所以对于将连续的两个数加载到寄存器可以使用“拼接使用”的方式，即高32位存储第一个数，低32位存储第二个数 -- instrs' combine

## 比较是否为同一个lir_basic_block

利用ObjPtr、std::ptr，比较是否指向同一个地址。hash trait也同理，通过hash指针指向的地址来判断

## call指令的参数寄存器的使用：

函数调用前保存参数寄存器问题，我们目前是以最坏的情况考虑，也就是所有参数寄存器都会被use，所以都放到use里(也就是说假设这些参数寄存器里的数据都会被被调用函数覆盖)，那么在计算本函数的寄存器分配时，发生溢出自然会完成“回填”的store。因为函数与函数之间的block不存在in和out edge关系，所以不需要考虑函数与函数间的影响

## 寄存器分配：

### 对于虚拟寄存器与物理寄存器的约定：

然后我们是假设虚拟寄存器id是唯一的，也就是说虚拟寄存器编号相同一定是同一个“变量”，但物理寄存器id不唯一，也就是说物理寄存器编号相同，也不一定是同一个“变量”

### 对于虚拟寄存器的约定：

虚拟寄存器分为两类，一类是长期持有的，另一类是临时工的，需要临时借用的。当某条指令出现spill的虚拟寄存器时，需要借用一个物理寄存器，并在该条指令结束之后还回它，并将该虚拟寄存器占用物理寄存器的值存到栈上

## ld/w sd/w

对于s/l to stack指令，额外添加一遍pass以确定原寄存器中的内容是否为地址，若是地址则调用d，否则调用w

# 算数优化(当一个操作数为立即数时)
以下优化未作额外说明默认为对整数(i32)使用
## 乘法
基础 RV32I ISA 中的大多数指令的执行仅需要 1 个指令时钟周期，经查阅，在一些架构中乘法指令需要5个时钟周期(星晖2可能也差不多？)，因此只对于特殊立即数乘法进行优化，即可以被拆为两个"整数"(这里的整数指的是2的n次幂)作加减，这样只消耗3个时钟周期，而算上取反也最多只需要4个时钟周期。

##
## 除法
* 2^n：移位n
* 非2^n且大于等于2：
使用*hacker's delight*一书中的算法，求出该除数(立即数)的魔法数，然后通过乘法与移位运算可求出商

## 求余
正常的除法指令需要20个周期以上
* 2^n： 
```r = ((n + t) & (2^k - 1)) - t; t = (n >> k - 1) >> 32 - k```


# 拆phi:
在一个block内若出现b型指令，则会紧跟着一条j型指令。含有控制流的程序的拆phi可将一个block分成3(或者4，最后一部分用于ret/b/j)部分：
进入block时将(从前继获得的)tmp保存至phi_reg；顺序执行；离开block前将src保存至tmp以便后继使用。

# 对于函数调用时发生的寄存器保存操作
需要把caller saved寄存器保存，否则在外部函数内很可能被修改！

在IR翻译为LIR的过程中，每一条指令对应的操作数，如果是寄存器，则代表虚拟寄存器(编号从32开始)，然后经由寄存器分配建立映射，并把一部分
物理寄存器保留使用。在处理spilling时会处理call调用函数对寄存器的影响，进行存取栈操作，处理逻辑如下：

建立一张hashmap，以物理寄存器作为key，以虚拟寄存器作为value，可以保证遍历到call指令时，物理寄存器对应着最近被使用的虚拟寄存器。
当遇到call指令时，在map中寻找那些“caller saved”物理寄存器，他们作为为：发生函数调用时，产生了“spill”情况，需要把这些物理寄存器对应虚拟寄存器存到栈上(但实际上存入的还是物理寄存器，可以使用HashSet代替HashMap。此处使用HashMap以便以后优化使用)，待函数调用结束后取回。

而对于callee_saved寄存器来说，如果当前函数不是main函数，callee_saved寄存器原来可能存有值，所以应在第一次要使用时保存，并在离开函数前恢复

# 处理循环中的数组/全局变量label的加载
将块类型分为循环团和非循环团，对于非循环团使用的虚拟寄存器相同，循环团之间(以及与非循环团间)的虚拟寄存器不同
                      ┌───────────┐
                      │           │
                      │     0     │
                      │           │
                      └────┬──────┘
                           │
                           │
                      ┌────▼──────┐
                      │           │
                      │     1     │
                      │           │◄─────────────┐
                      └┬─────────┬┘              │
                       │         │               │
                       │         │               │
                       │         │               │
             ┌─────────▼─┐     ┌─▼─────────┐     │
             │           │     │           │     │
             │     2     │     │     4     ├─────┘
┌───────────►│           │     │           │
│            └─┬─────────┘     └──┬────────┘
│              │                  │
│              │                  │
│     ┌────────▼──┐               │
│     │           │               │
└─────┤     3     ├───────┐       │
      │           │       │       │
      └───────────┘       │       │
                          │       │
                          │       │
                          │       │
                     ┌────▼───────▼───┐
                     │                │
                     │        5       │
                     │                │
                     │                │
                     └────────────────┘
在上述结构中，块0、5为非循环团，块1、2、3、4为**一个**循环团。块0、5使用共同的虚拟寄存器存储label，块1、2、3、4使用共同的虚拟寄存器。循环团外label寄存器的权重设置较低，较容易被split掉，而循环团内部label权重=权重*最深的循环层数，使之不容易被split掉。因此，不再每次手动的将label存到栈上再从栈上读取。

# 窥孔
1. 对于`mv a, b; mv c, a;`且a为end point，即a后面在def前不会用作use，则将原指令替换为`mv c, b`(这里a, b, c均为物理寄存器)
2. 对于`sd t0, offset1(sp); ld t0, offset1(sp)`，优化为将后一条ld指令删除掉；对于`sd t1, offset1(sp); ld t0, offset1(sp)`，将第二条ld改为`mv t0, t1`
3. 删除形如`mv a, a`的指令

# 块合并
当前策略为，在最后生成汇编前进行块合并，将j label的目标块和当前块合并，并考虑优先合并循环体，优化循环的跳转
对于b型指令，如果j对应的目标块只有一个来源，则可以将其向上合并

# callee & caller saved regs
需要