## 关于栈帧寄存器
由于sysy不涉及内联汇编，因此目前省略了s0的作为栈帧寄存器的特殊用法，从而使得寄存器分配过程多出一个非special的寄存器

## 涉及立即数跳转的j型指令和b型指令问题
若目标b/j型指令目标label大于4KB/1MB（如何得到目标block与pc的偏移以确定是否合法？）
解决：函数维护block编号，作差 * 指令数 * 代价

## 分支预测
如何尽可能保证程序顺序执行？

## gp优化
使用gp相对寻址(+- 2K)代替auipc + addi label 

## stack structure
┌──────────────────┐
│                  │
│     params       │
├──────────────────┤
│                  │
│       ...        │
├──────────────────┤
│                  │
│   alloca array   │
├──────────────────┤
│                  │
│                  │
│                  │
│                  │
│                  │
│       ...        │
│                  │
│                  │
│                  │
├──────────────────┤
│                  │
│     local var    │
├──────────────────┤
│                  │
│     local var    │
└──────────────────┘
使用LinkedList，函数参数、数组使用头插，局部变量使用尾插
List结构如下：
┌────────────────┐◄───────list head
│                │
│                │
│    alloca1     │
│                │
│                │
├────────────────┤
│                │
│                │
│    alloca0     │
├────────────────┤
│      ...       │
├────────────────┤
│                │
│     param1     │
│                │
├────────────────┤
│                │
│     param0     │
│                │
├────────────────┤
│                │
│  local var0    │
├────────────────┤
│                │
│  local var1    │
├────────────────┤
│                │
│      ...       │
└────────────────┘◄───────list tail

## alloca数组
通过la label获取数组第0个元素地址，一次ld加载两个数组值到栈上

## 优化跳转： 如果func的block集合中，下一个block是当前block的跳转对象，则省去跳转指令

## 压缩数据
由于使用的数值都是32位，所以对于将连续的两个数加载到寄存器可以使用“拼接使用”的方式，即高32位存储第一个数，低32位存储第二个数 -- instrs' combine

## 待修复
1. 读取栈上元素 - 目前采取“不弹栈”的方式，即栈帧固定，不会删除stackstlot链表中的slot
   1. 尤其是调用函数结束后恢复a0-a7


2. 计算栈容量： 溢出寄存器数量+(有效)数组容量+传入函数的栈上参数数量+调用函数而使用寄存器的数量(考虑函数调用结束后，恢复寄存器后，是否发生“弹栈”，因而这个数值不超过8 * 2 * 8)