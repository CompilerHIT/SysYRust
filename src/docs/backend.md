## 关于栈帧寄存器
由于sysy不涉及内联汇编，因此目前省略了s0的作为栈帧寄存器的特殊用法，从而使得寄存器分配过程多出一个非special的寄存器

## 涉及立即数跳转的j型指令和b型指令问题
若目标b/j型指令目标label大于4KB/1MB（如何得到目标block与pc的偏移以确定是否合法？）
解决：函数维护block编号，作差 * 指令数 * 代价

## 分支预测
如何尽可能保证程序顺序执行？

## gp优化
使用gp相对寻址(+- 2K)代替auipc + addi label 

## stack structure
┌──────────────────┐
│                  │
│     params       │
├──────────────────┤
│                  │
│       ...        │
├──────────────────┤
│                  │
│   alloca array   │
├──────────────────┤
│                  │
│                  │
│                  │
│                  │
│                  │
│       ...        │
│                  │
│                  │
│                  │
├──────────────────┤
│                  │
│     local var    │
├──────────────────┤
│                  │
│     local var    │
└──────────────────┘
使用LinkedList，函数参数、数组使用头插，局部变量使用尾插
List结构如下：
┌────────────────┐◄───────list head
│                │
│                │
│    alloca1     │
│                │
│                │
├────────────────┤
│                │
│                │
│    alloca0     │
├────────────────┤
│      ...       │
├────────────────┤
│                │
│     param1     │
│                │
├────────────────┤
│                │
│     param0     │
│                │
├────────────────┤
│                │
│  local var0    │
├────────────────┤
│                │
│  local var1    │
├────────────────┤
│                │
│      ...       │
└────────────────┘◄───────list tail

## alloca数组
通过la label获取数组第0个元素地址，一次ld加载两个数组值到栈上

## 优化跳转： 如果func的block集合中，下一个block是当前block的跳转对象，则省去跳转指令
