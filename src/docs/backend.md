## 关于栈帧寄存器

由于sysy不涉及内联汇编，因此目前省略了s0的作为栈帧寄存器的特殊用法，从而使得寄存器分配过程多出一个非special的寄存器

## 涉及立即数跳转的j型指令和b型指令问题

若目标b/j型指令目标label大于4KB/1MB（如何得到目标block与pc的偏移以确定是否合法？）
解决：函数维护block编号，作差 \* 指令数 \* 代价

## 分支预测

如何尽可能保证程序顺序执行？

## gp优化

使用gp相对寻址(+- 2K)代替auipc + addi label

## stack structure

┌──────────────────┐
│                  │
│     params       │
├──────────────────┤
│                  │
│       ...        │
├──────────────────┤
│                  │
│   alloca array   │
├──────────────────┤
│                  │
│                  │
│                  │
│                  │
│                  │
│       ...        │
│                  │
│                  │
│                  │
├──────────────────┤
│                  │
│     local var    │
├──────────────────┤
│                  │
│     local var    │
└──────────────────┘
使用LinkedList，函数参数、数组使用头插，局部变量使用尾插；
对于发生函数调用前，保存在栈上的参数寄存器，同样使用头插，调用StoreParamToStack（认为发生溢出行为）
List结构如下：
┌────────────────┐◄───────list head
│                │
│                │
│    alloca1     │
│                │
│                │
├────────────────┤
│                │
│                │
│    alloca0     │
├────────────────┤
│      ...       │
├────────────────┤
│                │
│     param1     │
│                │
├────────────────┤
│                │
│     param0     │
│                │
├────────────────┤
│                │
│  local var0    │
├────────────────┤
│                │
│  local var1    │
├────────────────┤
│                │
│      ...       │
└────────────────┘◄───────list tail

> 使用“预估法”所以不用记录每个局部变量的位置，即在stackslot中不保存local var

## alloca数组

通过la label获取数组第0个元素地址，一次ld加载两个数组值到栈上

## 优化跳转： 如果func的block集合中，下一个block是当前block的跳转对象，则省去跳转指令

## 压缩数据

由于使用的数值都是32位，所以对于将连续的两个数加载到寄存器可以使用“拼接使用”的方式，即高32位存储第一个数，低32位存储第二个数 -- instrs' combine

## 比较是否为同一个lir_basic_block

利用ObjPtr、std::ptr，比较是否指向同一个地址。hash trait也同理，通过hash指针指向的地址来判断

## call指令的参数寄存器的使用：

函数调用前保存参数寄存器问题，我们目前是以最坏的情况考虑，也就是所有参数寄存器都会被use，所以都放到use里(也就是说假设这些参数寄存器里的数据都会被被调用函数覆盖)，那么在计算本函数的寄存器分配时，发生溢出自然会完成“回填”的store。因为函数与函数之间的block不存在in和out edge关系，所以不需要考虑函数与函数间的影响

## 寄存器分配：

### 对于虚拟寄存器与物理寄存器的约定：

然后我们是假设虚拟寄存器id是唯一的，也就是说虚拟寄存器编号相同一定是同一个“变量”，但物理寄存器id不唯一，也就是说物理寄存器编号相同，也不一定是同一个“变量”

### 对于虚拟寄存器的约定：

虚拟寄存器分为两类，一类是长期持有的，另一类是临时工的，需要临时借用的。当某条指令出现spill的虚拟寄存器时，需要借用一个物理寄存器，并在该条指令结束之后还回它，并将该虚拟寄存器占用物理寄存器的值存到栈上

## ld/w sd/w

对于s/l to stack指令，额外添加一遍pass以确定原寄存器中的内容是否为地址，若是地址则调用d，否则调用w