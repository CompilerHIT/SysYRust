## 关于栈帧寄存器

省略了s0的作为栈帧寄存器的特殊用法，从而使得寄存器分配过程多出一个非special的寄存器

## 涉及立即数跳转的j型指令和b型指令问题

若目标b/j型指令目标label大于4KB/1MB（如何得到目标block与pc的偏移以确定是否合法？）
解决：函数维护block编号，作差 \* 指令数 \* 代价

## 分支预测

对条件取反，j的目标为条件体内部的代码，对诸如循环等更倾向于认为执行至少一次


## stack structure

┌───────────────┐ ◄───────s0
│               │
│     param     │
│               │
├───────────────┤
│               │
│   callee regs │
│               │
├───────────────┤
│               │
│               │
│               │
│               │
│     ...       │
│               │
│               │
│               │
│               │
├───────────────┤
│               │
│  local array  │
├───────────────┤
│               │
│  caller regs  │
├───────────────┤
│   local var   │
├───────────────┤ ◄───────── sp
│    next func  │
│   overflow    │
│      param    │
└───────────────┘

sp指向栈顶，s0代表栈底。来自caller函数的超过参数寄存器数量的参数在栈的最底部，紧邻着它的是callee saved寄存器；栈顶部依次是局部变量/caller saved regs和局部变量


## 寄存器分配：

### 对于虚拟寄存器与物理寄存器的约定：

然后我们是假设虚拟寄存器id是唯一的，也就是说虚拟寄存器编号相同一定是同一个“变量”，但物理寄存器id不唯一，也就是说物理寄存器编号相同，也不一定是同一个“变量”


# 算数优化(当一个操作数为立即数时)
以下优化未作额外说明默认为对整数(i32)使用
## 乘法
基础 RV32I ISA 中的大多数指令的执行仅需要 1 个指令时钟周期，经查阅，在一些架构中乘法指令需要5个时钟周期(星晖2可能也差不多？)，因此只对于特殊立即数乘法进行优化，即可以被拆为两个"整数"(这里的整数指的是2的n次幂)作加减，这样只消耗3个时钟周期，而算上取反也最多只需要4个时钟周期。

##
整数除法和求余运算需要6-60个时钟周期，使用优化后的除法和求余运算，通过移位得到商，可在6个时钟周期完成。
## 除法
* 2^n：移位n
* 非2^n且大于等于2：
使用*hacker's delight*一书中的算法，求出该除数(立即数)的魔法数，然后通过乘法与移位运算可求出商

## 求余
* 2^n： 
```r = ((n + t) & (2^k - 1)) - t; t = (n >> k - 1) >> 32 - k```


# 拆phi:
SSA形式IR使用phi指令来确定数据流的来源，因此后端的拆phi为，将来源在“来源块”的末尾mv到临时寄存器中，然后在使用到phi的块中将临时寄存器的值mv到phi寄存器。这种操作会带来一定冗余的mv指令，但可以在块合并后的指令删除过程中删除掉。


# 指令消除

# 块合并
* 当前块只有一条跳转指令，将该块删除，并修改其前驱的跳转目标、前驱的后继、后继的前驱
* 如果一个块的终止指令是直接跳转, 且直接跳转到的基本块里有且只有一条直接跳转的指令, 那么就把这个二次跳转消除。要求中间那个只有一条跳转指令的基本块的前继只有一个。
* 在直接跳转到另一个块, 并且跳转目标块没有其它前继的情况下, 可以直接把两个块合成为一个大块
* 若branch的下一条jump指令的目标块，只有一个前驱，则将该jump指令删除，并将其合并到这个块中
* 如果branch和其紧邻的jump语句的目标块相同，则将jump语句删除
* 清除空块(包括entry块)
* jump的目标块如果紧邻，则删除jump语句